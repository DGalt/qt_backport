
#Patching notes:
# - All QMatrix usages may need to be converted to QTransform.  QMatrix is now
#    obsolete.  Fortunately, Qt has preserved the conversion of them by using
#    the QTransform(QMatrix) overload.  Many functions simply do not support
#    QMatrix anymore and there is no replacement that is not a QTransform.  eg:
#    see QPainter.combinedMatrix() and QPainter.deviceMatrix()... their new
#    replacements *only* deal with QTransform.

import sys
import inspect

import PyQt5
from PyQt5 import QtWidgets      as _PyQt5_QtWidgets
from PyQt5 import QtGui          as _PyQt5_QtGui
from PyQt5 import QtCore         as _PyQt5_QtCore
from PyQt5 import QtPrintSupport as _PyQt5_QtPrintSupport
from PyQt5 import QtMultimedia   as _PyQt5_QtMultimedia
from PyQt5 import QtX11Extras    as _PyQt5_QtX11Extras

_OBSOLETE_ = "__obsolete__in__Qt5__"

def get_qt_class_names(module):
    return tuple(sorted(x.__name__ for x in module.__dict__.values() 
                        if (inspect.isclass(x) and x.__name__.startswith("Q"))))

#Set the list of classes that need to be re-assembled back into QtGui...
# - note that using get_qt_class_names to find backports will cause Qt5-only
#   classes to appear in the PyQt4.QtGui namespace.  Since our only purpose is
#   to make old code work, this namespace pollution is fine.  Old code will not
#   use them.  We will try and be tidy when it would be excessive, though (eg:
#   only a few QtGui classes ended up moving to QtCore).
QtWidgets_backports = get_qt_class_names(_PyQt5_QtWidgets) #new module
QtPrintSupport_backports = get_qt_class_names(_PyQt5_QtPrintSupport) #new module
QtCore_backports = ('QAbstractProxyModel', 'QItemSelection', 'QItemSelectionModel', 'QItemSelectionRange', 'QSortFilterProxyModel', 'QStringListModel', )
QtMultimedia_backports = ('QSound', )
QtX11Extras_backports = ('QX11Info', )

#class names below were dropped from Qt4 to Qt5
# - this is not used, but is for reference if/when resolving issues
# - list was generated by comparing PySide.QtGui to PyQt5.QtGui, so this may
#    not be 100% correct.  The correct statement is "PySide.QtGui had these
#    classes, but they do not exist in Qt5"
unavailable_in_qt5 = ('AbstractPageSetupDialog', 'QCDEStyle', 'QCleanlooksStyle', 'QClipboardEvent', 'QGraphicsItemAnimation', 'QGtkStyle', 'QIconEngine', 'QInputContext', 'QInputContextFactory', 'QMotifStyle', 'QPlastiqueStyle', 'QProxyModel', 'QPyTextObject', 'QToolBarChangeEvent', 'QWindowsStyle', 'QWorkspace', 'QX11EmbedContainer', 'QX11EmbedWidget')

#class names that exist in Qt5, but are not available in PyQt5 for some reason
# - also not used, but here for reference
unavailable_in_pyqt5 = (
    'QAccessibleEvent', #http://qt-project.org/doc/qt-5/qaccessibleevent.html
    'QMatrix', #deprecated (but 2x2 etc variants still exist for some reason)
    'QTileRules', #http://qt-project.org/doc/qt-5/qtilerules.html
    # style option synonyms below are not in PyQt5, but are doc'd in Qt5 ###
    'QStyleOptionDockWidgetV2','QStyleOptionFrameV2','QStyleOptionFrameV3', 'QStyleOptionProgressBarV2','QStyleOptionTabBarBaseV2', 'QStyleOptionTabV2', 'QStyleOptionTabV3', 'QStyleOptionToolBoxV2','QStyleOptionViewItemV2', 'QStyleOptionViewItemV3','QStyleOptionViewItemV4',
)

def get_arg(args, kwargs, arg_index, key, d):
    try:
        ret = args[arg_index]
    except IndexError:
        try:
            ret = kwargs[key]
        except KeyError:
            ret = d
    return ret

def _FN_NOT_PORTED_YET_(fn):
    def raise_err(self, *args, **kwargs):
        err_msg = "qt5_backport has not ported '%s' yet" % fn
        raise NotImplementedError(err_msg)
    return raise_err

def _reassemble_QtGui():
    """Reassembles the dispersed Qt4.QtGui classes"""
    backport_info = {QtWidgets_backports:      _PyQt5_QtWidgets,
                     QtPrintSupport_backports: _PyQt5_QtPrintSupport,
                     QtCore_backports:         _PyQt5_QtCore,
                     QtMultimedia_backports:   _PyQt5_QtMultimedia,
                     QtX11Extras_backports:    _PyQt5_QtX11Extras,
                     }
    for cls_names, module in backport_info.iteritems():
        for cls_name in cls_names:
            cls = getattr(module, cls_name)
            setattr(_PyQt5_QtGui, cls_name, cls)

def _patch_QApplication():
    cls = _PyQt5_QtWidgets.QApplication
    
    cls.UnicodeUTF8 = _OBSOLETE_
    
    old_translate = cls.translate
    @staticmethod
    def _translate(context, sourceText, disambiguation, *args):
        #all encoding is now done with UTF-8.  See these links:
        # - http://qt-project.org/wiki/Transition_from_Qt_4.x_to_Qt5#3a05fcdc7ec52801754a96d4b80c301b
        # - http://qt-project.org/doc/qt-4.8/qcoreapplication.html#translate
        # - http://qt-project.org/doc/qt-5/qcoreapplication.html#translate
        if len(args) == 2:
            encoding, n = args
            return old_translate(context, sourceText, disambiguation, n)
        elif len(args) == 1:
            #If it is old code calling us it should be encoding. If new code,
            #it would be n. However, we are expecting old code so we will
            #assume it is encoding (and ignore it).  n will be default.
            return old_translate(context, sourceText, disambiguation)
    cls.translate = _translate

def _patch_QColor():
    #see http://qt-project.org/doc/qt-5/qcolor-obsolete.html
    cls = _PyQt5_QtGui.QColor
    cls.light = lambda(self): self.lighter() #Qt4.2 -> Qt4.3
    cls.dark  = lambda(self): self.darker()  #Qt4.2 -> Qt4.3

def _patch_QGraphicsItem():
    #see http://qt-project.org/doc/qt-5/qgraphicsitem-compat.html
    cls = _PyQt5_QtGui.QGraphicsItem
    transform_cls = _PyQt5_QtGui.QTransform
    cls.acceptsHoverEvents = lambda self: self.acceptHoverEvents()
    cls.setAcceptsHoverEvents = lambda self, enabled: self.acceptHoverEvents(enabled)
    cls.children = lambda self: self.childItems()
    cls.rotate = lambda self, angle: self.setRotation(angle)
    cls.scale = lambda self, sx, sy: self.setTransform(transform_cls.fromScale(sx, sy), True)
    cls.translate = lambda self, dx, dy: self.moveBy(dx, dy)
    cls.shear = lambda self, sh, sv: self.setTransform(transform_cls().shear(sh, sv), True)

def _patch_QHeaderView():
    #see http://qt-project.org/doc/qt-5/qheaderview-compat.html
    cls = _PyQt5_QtWidgets.QHeaderView
    cls.isClickable = lambda self: self.sectionsClickable()
    cls.isMovable = lambda self: self.secionsMovable()
    cls.resizeMode = lambda self, logicalIndex: self.sectionResizeMode(logicalIndex)
    cls.setClickable = lambda self, clickable: self.setSectionsClickable(clickable)
    cls.setMovable = lambda self, movable: self.setSectionsMovable(movable)
    def setResizeMode(self, *args): #overloads are (mode, ) and (logicalIndex, mode)
        return self.setSectionResizeMode(*args)
    cls.setResizeMode = setResizeMode

def _patch_QPainter():
    #see http://qt-project.org/doc/qt-5/qpainter-obsolete.html
    cls = _PyQt5_QtGui.QPainter
    
    def _drawRoundRect(self, *args, **kwargs):
        arg_types = tuple(type(arg) for arg in args)
        if arg_types[:4] == (int, int, int, int):
            #overload is (x, y, w, h, xRnd, yRnd) or (int * 6)
            x, y, w, h = args[:4]
            xRnd = get_arg(args, kwargs, 4, "xRnd", 25)
            yRnd = get_arg(args, kwargs, 5, "yRnd", 25)
            return self.drawRoundedRect(x, y, w, h, xRnd, yRnd)
        else:
            rect = args[0]
            xRnd = get_arg(args, kwargs, 1, "xRnd", 25)
            yRnd = get_arg(args, kwargs, 2, "yRnd", 25)
            return self.drawRoundedRect(rect, xRnd, yRnd)
    
    cls.combinedMatrix = lambda self: self.combinedTransform() #QMatrix is obsolete
    cls.deviceMatrix = lambda self: self.deviceTransform() #QMatrix is obsolete
    cls.drawRoundRect = _drawRoundRect
    cls.initFrom = lambda self, device: self.begin(device)
    cls.matrix = lambda self: self.worldTransform() #QMatrix is obsolete
    cls.matrixEnabled = lambda self: self.worldMatrixEnabled()
    cls.redirected = _FN_NOT_PORTED_YET_("QPainter.redirected") #Consider QWidget.render
    cls.resetMatrix = _FN_NOT_PORTED_YET_("QPainter.resetMatrix") #convert to QTransform somehow
    cls.restoreRedirected = _FN_NOT_PORTED_YET_("QPainter.restoreRedirected") #Consider QWidget.render
    def _setMatrix(self, matrix, combine):
        assert isinstance(matrix, _PyQt5_QtGui.QTransform) #All QMatrix must now be QTransform
        return self.setWorldTransform(matrix, combine)
    cls.setMatrix = _setMatrix
    cls.setMatrixEnabled = lambda self, enable: self.setWorldMatrixEnabled(enable)
    cls.setRedirected = _FN_NOT_PORTED_YET_("QPainter.setRedirected") #Consider QWidget.render
    def _setWorldMatrix(self, matrix, combine):
        assert isinstance(matrix, _PyQt5_QtGui.QTransform) #All QMatrix must now be QTransform
        return self.setWorldTransform(matrix, combine)
    cls.setWorldMatrix = _setWorldMatrix
    cls.worldMatrix = lambda self: self.worldTransform()
    
def _patch_QPainterPath():
    cls = _PyQt5_QtGui.QPainterPath
    
    old_toSubpathPolygons = cls.toSubpathPolygons
    def toSubpathPolygons(self, *args):
        if len(args) == 0:
            t = _PyQt5_QtGui.QTransform() #identity matrix
            return old_toSubpathPolygons(self, t)
        else:
            return old_toSubpathPolygons(self, *args)
    
    old_toFillPolygons = cls.toFillPolygons
    def toFillPolygons(self, *args):
        if len(args) == 0:
            t = _PyQt5_QtGui.QTransform() #identity matrix
            return old_toFillPolygons(self, t)
        else:
            return old_toFillPolygons(self, *args)
    
    cls.toSubpathPolygons = toSubpathPolygons
    cls.toFillPolygons = toFillPolygons
    
def _patch_QRectF():
    #see http://qt-project.org/doc/qt-5/qrectf-compat.html
    cls = PyQt5.QtCore.QRectF
    cls.intersect = lambda self, rectangle: self.intersected(rectangle)
    cls.unite = lambda self, rectangle: self.united(rectangle)

def _patch_QWheelEvent():
    #see http://qt-project.org/doc/qt-5/qwheelevent-obsolete.html
    cls = _PyQt5_QtGui.QWheelEvent
    
    old_qt5__QWheelEvent_init = cls.__init__
    def _QWheelEvent_init(self, *args, **kwargs):
        #This is tricky... arrival here can be from a few different sources
        #(not including overload issues). The callers can be:
        #   1. PyQt5/Qt5 internal generation
        #        - in this case we get no args or kwargs (unsure why, but this
        #           is what happens), but we have nothing to do since it is
        #           already in Qt5 form.
        #   2. Caller is manually generating the arguments in the old Qt4 way
        #   3. Caller is manually generating the arguments in the old Qt4 way,
        #       but using data from a pre-existgin Qt5 QWheelEvent
        #        - this is a bit of a hybrid case we need to cover
        #        - this case was triggered by pyqtgraph's RemoteGraphicsView
        #Note that, since we are using qt5_backport, we should be able to
        #assume that existing code is using Qt4 conventions (where possible)
        if (args == ()) and (kwargs == {}): #Case 1 above
            #This happens when something internal to PyQt5/Qt5 generated the
            #event. In this case, it is a properly formed event and we don't
            #need to do anything.
            old_qt5__QWheelEvent_init(self, *args, **kwargs)
            return
        else:
            #getting here means someone is creating an event instance manually
            #print "~~~~~`%r %r" % (args, kwargs)
            _qpoint = _PyQt5_QtCore.QPoint     #local space/lookup saver
            _qpointf = _PyQt5_QtCore.QPointF   #local space/lookup saver
            #Do some overload detection and get the args we need...
            if isinstance(args[1], int):
                #we have the old Qt4 overload without globalPos
                orientIdx = 4
                pos, delta, buttons, modifiers = args[:orientIdx]
                globalPos = PyQt5.QtGui.QCursor.pos()
            #elif isinstance(args[1], _PyQt5_QtCore.QPointF)
            else:
                #we have the overload *with* globalPos
                orientIdx = 5
                pos, globalPos, delta, buttons, modifiers = args[:orientIdx]
            try:
                orient = args[orientIdx]
            except IndexError:
                orient = kwargs.get("orient", _PyQt5_QtCore.Qt.Vertical)
            
            #we now have all the potential Qt4 constructor args.  Time to
            #convert them into Qt5-speak...
            if isinstance(pos, _qpoint): #hybrid case
                pos = _qpointf(pos)
            if isinstance(globalPos, _qpoint): #hybrid case
                globalPos = _qpointf(globalPos)

            pixelDelta = _qpoint(0, 0) #determined by experiment
            assert isinstance(delta, int)
            if type(delta) in (_qpoint, _qpointf):
                 #shouldn't happen
                raise Exception("delta should not be a QPoint or QPointF here!")
            elif orient == _PyQt5_QtCore.Qt.Vertical:
                angleDelta = _PyQt5_QtCore.QPoint(0, delta)
            else:
                angleDelta = _PyQt5_QtCore.QPoint(delta, 0)
            qt4Delta = delta
            qt4Orientation = orient
            
            #args are now all fixed up from Qt4->Qt5, so invoke the original...
            args = (self, pos, globalPos, pixelDelta,
                    angleDelta, qt4Delta, qt4Orientation,
                    buttons, modifiers)
            old_qt5__QWheelEvent_init(*args)
        
    def _QWheelEvent_delta(self):
        angle = self.angleDelta()
        return angle.y()
    def _QWheelEvent_orientation(self):
        #going with an orthogonal assumption here.  old orientation() docs are
        #less than clear.
        if self.angleDelta().x():
            ret = _PyQt5_QtCore.Qt.Horizontal
        elif self.angleDelta().y():
            ret = _PyQt5_QtCore.Qt.Vertical
        else:
            ret = 0  #old code seems to expect this
        #print "orientation = %r" % ret
        return ret
    cls.__init__ = _QWheelEvent_init
    cls.delta       = _QWheelEvent_delta
    cls.orientation = _QWheelEvent_orientation



def patch_api():
    """Applies patches to make old api usage work with PyQt5.
    
    This does several things:
      1. Implements obsolete api calls on top of new apis
           - eg: QColor.dark() -> QColor.darker()
      2. Adapts call signatures when they changed
           - eg: QApplication.translate() has a new set of args in Qt5.
      3. Whatever else is needed to make old code work!
    
    """
    
    #Note that Qt5 has several members that are either totally obsolete, or
    #part of the "Qt compatibility layer" that the Qt docs say "We advise
    #against using them in new code.". For the softer advisory warning, PyQt5
    #does not seem to include the "compatibility" members at all. This is
    #fine, but seems to be jumpingthe gun a bit. Since our purpose *is* to
    #deal with old code these members (or many of them) have been added in
    #the patches below.
    _patch_QApplication()
    _patch_QColor()
    _patch_QGraphicsItem()
    _patch_QHeaderView()
    _patch_QPainter()
    _patch_QPainterPath()
    _patch_QRectF()
    _patch_QWheelEvent()
    
    #And likely plenty more to come!
    
